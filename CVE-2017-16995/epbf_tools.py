import sys
opcode = []
for i in range(256):
	opcode.append('invalid opcode')
code = '''
		"\xb4\x09\x00\x00\xff\xff\xff\xff"
		"\x55\x09\x02\x00\xff\xff\xff\xff"
		"\xb7\x00\x00\x00\x00\x00\x00\x00"
		"\x95\x00\x00\x00\x00\x00\x00\x00"
		"\x18\x19\x00\x00\x03\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00"
		"\xbf\x91\x00\x00\x00\x00\x00\x00"
		"\xbf\xa2\x00\x00\x00\x00\x00\x00"
		"\x07\x02\x00\x00\xfc\xff\xff\xff"
		"\x62\x0a\xfc\xff\x00\x00\x00\x00"
		"\x85\x00\x00\x00\x01\x00\x00\x00"
		"\x55\x00\x01\x00\x00\x00\x00\x00"
		"\x95\x00\x00\x00\x00\x00\x00\x00"
		"\x79\x06\x00\x00\x00\x00\x00\x00"
		"\xbf\x91\x00\x00\x00\x00\x00\x00"
		"\xbf\xa2\x00\x00\x00\x00\x00\x00"
		"\x07\x02\x00\x00\xfc\xff\xff\xff"
		"\x62\x0a\xfc\xff\x01\x00\x00\x00"
		"\x85\x00\x00\x00\x01\x00\x00\x00"
		"\x55\x00\x01\x00\x00\x00\x00\x00"
		"\x95\x00\x00\x00\x00\x00\x00\x00"
		"\x79\x07\x00\x00\x00\x00\x00\x00"
		"\xbf\x91\x00\x00\x00\x00\x00\x00"
		"\xbf\xa2\x00\x00\x00\x00\x00\x00"
		"\x07\x02\x00\x00\xfc\xff\xff\xff"
		"\x62\x0a\xfc\xff\x02\x00\x00\x00"
		"\x85\x00\x00\x00\x01\x00\x00\x00"
		"\x55\x00\x01\x00\x00\x00\x00\x00"
		"\x95\x00\x00\x00\x00\x00\x00\x00"
		"\x79\x08\x00\x00\x00\x00\x00\x00"
		"\xbf\x02\x00\x00\x00\x00\x00\x00"
		"\xb7\x00\x00\x00\x00\x00\x00\x00"
		"\x55\x06\x03\x00\x00\x00\x00\x00"
		"\x79\x73\x00\x00\x00\x00\x00\x00"
		"\x7b\x32\x00\x00\x00\x00\x00\x00"
		"\x95\x00\x00\x00\x00\x00\x00\x00"
		"\x55\x06\x02\x00\x01\x00\x00\x00"
		"\x7b\xa2\x00\x00\x00\x00\x00\x00"
		"\x95\x00\x00\x00\x00\x00\x00\x00"
		"\x7b\x87\x00\x00\x00\x00\x00\x00"
		"\x95\x00\x00\x00\x00\x00\x00\x00"

'''

rules='''
	ALU_MOV_K(0,9,0x0,0xffffffff)
	JMP_JNE_K(0,9,0x2,0xffffffff)
	ALU64_MOV_K(0,0,0x0,0x0)
	JMP_EXIT(0,0,0x0,0x0)
	LD_IMM_DW(1,9,0x0,0x3)
	padding
	ALU64_MOV_X(9,1,0x0,0x0)
	ALU64_MOV_X(10,2,0x0,0x0)
	ALU64_ADD_K(0,2,0x0,0xfffffffc)
	ST_MEM_W(0,10,0xfffc,0x0)
	JMP_CALL(0,0,0x0,0x1)
	JMP_JNE_K(0,0,0x1,0x0)
	JMP_EXIT(0,0,0x0,0x0)
	LDX_MEM_DW(0,6,0x0,0x0)
	ALU64_MOV_X(9,1,0x0,0x0)
	ALU64_MOV_X(10,2,0x0,0x0)
	ALU64_ADD_K(0,2,0x0,0xfffffffc)
	ST_MEM_W(0,10,0xfffc,0x1)
	JMP_CALL(0,0,0x0,0x1)
	JMP_JNE_K(0,0,0x1,0x0)
	JMP_EXIT(0,0,0x0,0x0)
	LDX_MEM_DW(0,7,0x0,0x0)
	ALU64_MOV_X(9,1,0x0,0x0)
	ALU64_MOV_X(10,2,0x0,0x0)
	ALU64_ADD_K(0,2,0x0,0xfffffffc)
	ST_MEM_W(0,10,0xfffc,0x2)
	JMP_CALL(0,0,0x0,0x1)
	JMP_JNE_K(0,0,0x1,0x0)
	JMP_EXIT(0,0,0x0,0x0)
	LDX_MEM_DW(0,8,0x0,0x0)
	ALU64_MOV_X(0,2,0x0,0x0)
	ALU64_MOV_K(0,0,0x0,0x0)
	JMP_JNE_K(0,6,0x3,0x0)
	LDX_MEM_DW(7,3,0x0,0x0)
	STX_MEM_DW(3,2,0x0,0x0)
	JMP_EXIT(0,0,0x0,0x0)
	JMP_JNE_K(0,6,0x2,0x1)
	STX_MEM_DW(10,2,0x0,0x0)
	JMP_EXIT(0,0,0x0,0x0)
	STX_MEM_DW(8,7,0x0,0x0)
	JMP_EXIT(0,0,0x0,0x0)
'''

BPF_LD	= 0x00
BPF_LDX	= 0x01
BPF_ST	= 0x02
BPF_STX	= 0x03
BPF_ALU	= 0x04
BPF_JMP	= 0x05
BPF_RET	= 0x06
BPF_MISC= 0x07
BPF_W	= 0x00
BPF_H	= 0x08
BPF_B	= 0x10

BPF_IMM	= 0x00
BPF_ABS	= 0x20
BPF_IND	= 0x40
BPF_MEM	= 0x60
BPF_LEN	= 0x80
BPF_MSH	= 0xa0

BPF_ADD	= 0x00
BPF_SUB	= 0x10
BPF_MUL	= 0x20
BPF_DIV	= 0x30
BPF_OR	= 0x40
BPF_AND	= 0x50
BPF_LSH	= 0x60
BPF_RSH	= 0x70
BPF_NEG	= 0x80
BPF_MOD	= 0x90
BPF_XOR	= 0xa0

BPF_JA	= 0x00
BPF_JEQ	= 0x10
BPF_JGT	= 0x20
BPF_JGE	= 0x30
BPF_JSET= 0x40
BPF_K	= 0x00
BPF_X	= 0x08

BPF_ALU64	=0x07	#/* alu mode in double word width */
BPF_DW		=0x18	#/* double word */
BPF_XADD	=0xc0	#/* exclusive add */
BPF_MOV		=0xb0	#/* mov reg to reg */
BPF_ARSH	=0xc0	#/* sign extending arithmetic shift right */
BPF_END		=0xd0	#/* flags for endianness conversion: */
BPF_TO_LE	=0x00	#/* convert to little-endian */
BPF_TO_BE	=0x08	#/* convert to big-endian */
BPF_JNE		=0x50	#/* jump != */
BPF_JSGT	=0x60	#/* SGT is signed '>', GT in x86 */
BPF_JSGE	=0x70	#/* SGE is signed '>=', GE in x86 */
BPF_CALL	=0x80	#/* function call */
BPF_EXIT	=0x90	#/* function return */

opcode[BPF_ALU | BPF_ADD | BPF_X] = "ALU_ADD_X"
opcode[BPF_ALU | BPF_ADD | BPF_K] = "ALU_ADD_K"
opcode[BPF_ALU | BPF_SUB | BPF_X] = "ALU_SUB_X"
opcode[BPF_ALU | BPF_SUB | BPF_K] = "ALU_SUB_K"
opcode[BPF_ALU | BPF_AND | BPF_X] = "ALU_AND_X"
opcode[BPF_ALU | BPF_AND | BPF_K] = "ALU_AND_K"
opcode[BPF_ALU | BPF_OR | BPF_X]  = "ALU_OR_X"
opcode[BPF_ALU | BPF_OR | BPF_K]  = "ALU_OR_K"
opcode[BPF_ALU | BPF_LSH | BPF_X] = "ALU_LSH_X"
opcode[BPF_ALU | BPF_LSH | BPF_K] = "ALU_LSH_K"
opcode[BPF_ALU | BPF_RSH | BPF_X] = "ALU_RSH_X"
opcode[BPF_ALU | BPF_RSH | BPF_K] = "ALU_RSH_K"
opcode[BPF_ALU | BPF_XOR | BPF_X] = "ALU_XOR_X"
opcode[BPF_ALU | BPF_XOR | BPF_K] = "ALU_XOR_K"
opcode[BPF_ALU | BPF_MUL | BPF_X] = "ALU_MUL_X"
opcode[BPF_ALU | BPF_MUL | BPF_K] = "ALU_MUL_K"
opcode[BPF_ALU | BPF_MOV | BPF_X] = "ALU_MOV_X"
opcode[BPF_ALU | BPF_MOV | BPF_K] = "ALU_MOV_K"
opcode[BPF_ALU | BPF_DIV | BPF_X] = "ALU_DIV_X"
opcode[BPF_ALU | BPF_DIV | BPF_K] = "ALU_DIV_K"
opcode[BPF_ALU | BPF_MOD | BPF_X] = "ALU_MOD_X"
opcode[BPF_ALU | BPF_MOD | BPF_K] = "ALU_MOD_K"
opcode[BPF_ALU | BPF_NEG] = "ALU_NEG"
opcode[BPF_ALU | BPF_END | BPF_TO_BE] = "ALU_END_TO_BE"
opcode[BPF_ALU | BPF_END | BPF_TO_LE] = "ALU_END_TO_LE"
#/* 64 bit ALU operations */
opcode[BPF_ALU64 | BPF_ADD | BPF_X] = "ALU64_ADD_X"
opcode[BPF_ALU64 | BPF_ADD | BPF_K] = "ALU64_ADD_K"
opcode[BPF_ALU64 | BPF_SUB | BPF_X] = "ALU64_SUB_X"
opcode[BPF_ALU64 | BPF_SUB | BPF_K] = "ALU64_SUB_K"
opcode[BPF_ALU64 | BPF_AND | BPF_X] = "ALU64_AND_X"
opcode[BPF_ALU64 | BPF_AND | BPF_K] = "ALU64_AND_K"
opcode[BPF_ALU64 | BPF_OR | BPF_X] = "ALU64_OR_X"
opcode[BPF_ALU64 | BPF_OR | BPF_K] = "ALU64_OR_K"
opcode[BPF_ALU64 | BPF_LSH | BPF_X] = "ALU64_LSH_X"
opcode[BPF_ALU64 | BPF_LSH | BPF_K] = "ALU64_LSH_K"
opcode[BPF_ALU64 | BPF_RSH | BPF_X] = "ALU64_RSH_X"
opcode[BPF_ALU64 | BPF_RSH | BPF_K] = "ALU64_RSH_K"
opcode[BPF_ALU64 | BPF_XOR | BPF_X] = "ALU64_XOR_X"
opcode[BPF_ALU64 | BPF_XOR | BPF_K] = "ALU64_XOR_K"
opcode[BPF_ALU64 | BPF_MUL | BPF_X] = "ALU64_MUL_X"
opcode[BPF_ALU64 | BPF_MUL | BPF_K] = "ALU64_MUL_K"
opcode[BPF_ALU64 | BPF_MOV | BPF_X] = "ALU64_MOV_X"
opcode[BPF_ALU64 | BPF_MOV | BPF_K] = "ALU64_MOV_K"
opcode[BPF_ALU64 | BPF_ARSH | BPF_X] = "ALU64_ARSH_X"
opcode[BPF_ALU64 | BPF_ARSH | BPF_K] = "ALU64_ARSH_K"
opcode[BPF_ALU64 | BPF_DIV | BPF_X] = "ALU64_DIV_X"
opcode[BPF_ALU64 | BPF_DIV | BPF_K] = "ALU64_DIV_K"
opcode[BPF_ALU64 | BPF_MOD | BPF_X] = "ALU64_MOD_X"
opcode[BPF_ALU64 | BPF_MOD | BPF_K] = "ALU64_MOD_K"
opcode[BPF_ALU64 | BPF_NEG] = "ALU64_NEG"
#/* Call instruction */
opcode[BPF_JMP | BPF_CALL] = "JMP_CALL"
opcode[BPF_JMP | BPF_CALL | BPF_X] = "JMP_TAIL_CALL"
#/* Jumps */
opcode[BPF_JMP | BPF_JA] = "JMP_JA"
opcode[BPF_JMP | BPF_JEQ | BPF_X] = "JMP_JEQ_X"
opcode[BPF_JMP | BPF_JEQ | BPF_K] = "JMP_JEQ_K"
opcode[BPF_JMP | BPF_JNE | BPF_X] = "JMP_JNE_X"
opcode[BPF_JMP | BPF_JNE | BPF_K] = "JMP_JNE_K"
opcode[BPF_JMP | BPF_JGT | BPF_X] = "JMP_JGT_X"
opcode[BPF_JMP | BPF_JGT | BPF_K] = "JMP_JGT_K"
opcode[BPF_JMP | BPF_JGE | BPF_X] = "JMP_JGE_X"
opcode[BPF_JMP | BPF_JGE | BPF_K] = "JMP_JGE_K"
opcode[BPF_JMP | BPF_JSGT | BPF_X] = "JMP_JSGT_X"
opcode[BPF_JMP | BPF_JSGT | BPF_K] = "JMP_JSGT_K"
opcode[BPF_JMP | BPF_JSGE | BPF_X] = "JMP_JSGE_X"
opcode[BPF_JMP | BPF_JSGE | BPF_K] = "JMP_JSGE_K"
opcode[BPF_JMP | BPF_JSET | BPF_X] = "JMP_JSET_X"
opcode[BPF_JMP | BPF_JSET | BPF_K] = "JMP_JSET_K"
#/* Program return */
opcode[BPF_JMP | BPF_EXIT] = "JMP_EXIT"
#/* Store instructions */
opcode[BPF_STX | BPF_MEM | BPF_B] = "STX_MEM_B"
opcode[BPF_STX | BPF_MEM | BPF_H] = "STX_MEM_H"
opcode[BPF_STX | BPF_MEM | BPF_W] = "STX_MEM_W"
opcode[BPF_STX | BPF_MEM | BPF_DW] = "STX_MEM_DW"
opcode[BPF_STX | BPF_XADD | BPF_W] = "STX_XADD_W"
opcode[BPF_STX | BPF_XADD | BPF_DW] = "STX_XADD_DW"
opcode[BPF_ST | BPF_MEM | BPF_B] = "ST_MEM_B"
opcode[BPF_ST | BPF_MEM | BPF_H] = "ST_MEM_H"
opcode[BPF_ST | BPF_MEM | BPF_W] = "ST_MEM_W"
opcode[BPF_ST | BPF_MEM | BPF_DW] = "ST_MEM_DW"
#/* Load instructions */
opcode[BPF_LDX | BPF_MEM | BPF_B] = "LDX_MEM_B"
opcode[BPF_LDX | BPF_MEM | BPF_H] = "LDX_MEM_H"
opcode[BPF_LDX | BPF_MEM | BPF_W] = "LDX_MEM_W"
opcode[BPF_LDX | BPF_MEM | BPF_DW] = "LDX_MEM_DW"
opcode[BPF_LD | BPF_ABS | BPF_W] = "LD_ABS_W"
opcode[BPF_LD | BPF_ABS | BPF_H] = "LD_ABS_H"
opcode[BPF_LD | BPF_ABS | BPF_B] = "LD_ABS_B"
opcode[BPF_LD | BPF_IND | BPF_W] = "LD_IND_W"
opcode[BPF_LD | BPF_IND | BPF_H] = "LD_IND_H"
opcode[BPF_LD | BPF_IND | BPF_B] = "LD_IND_B"
opcode[BPF_LD | BPF_IMM | BPF_DW] = "LD_IMM_DW"

def u16(imm):
	if len(imm)!=2:
		print '[-] u16 must have a correct input like "\\x12\\x34"'
		exit()
	return (ord(imm[1])<<8)+ord(imm[0])
def u32(imm):
	if len(imm)!=4:
		print '[-] u32 must have a correct input like "\x12\x34\x56\x78"'
		exit()
	return (ord(imm[1])<<8)+ord(imm[0])	+(ord(imm[2])<<16)+(ord(imm[3])<<24)
def p16(imm):
	result = ''
	for i in range(2):
		result += "\\x"+ hex((imm>>(8*(i)))&0xff).replace('0x','').rjust(2,'0')
	return result
def p32(imm):
	result = ''
	for i in range(4):
		result += "\\x"+ hex((imm>>(8*(i)))&0xff).replace('0x','').replace('L','').rjust(2,'0')
	return result	


def decode_single(idx,insn):
	#print insn.encode('hex')
	op = opcode[ord(insn[0])]
	reg = ord(insn[1])
	off = insn[2:4]
	imm = insn[4:]
	if op == 'invalid opcode':
		print '[%d]: maybe padding'%idx
		return
	print "[%d]: %s(%s,%s,%s,%s)"%(idx,op,str(reg>>4),str(reg&0x0f),hex(u16(off)).replace('L',''),hex(u32(imm)).replace('L',''))

def decode_all(insn_tmp):
	insn = insn_tmp.split('"\n')
	i  = 0
	for ins in insn:
		ins = ins.strip()
		if len(ins)<9:
			break
		if ins[-9]!= '"':
			print '[-] format error!'
			exit()
		decode_single(i,ins[-8:])
		i += 1

def banner_decode():
	print '[+] A tools for decode ebpf rules by P4nda'
	print '[+] modify code in script as format :'
	print '========================================================='
	print '\t\t"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00"'
	print '\t\t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"'
	print '\t\t"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00"'
	print '\t\t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"'
	print '\t\t"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00"'
	print '\t\t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"'	
	print '========================================================='	
	print 'result format: \t[index]: opcode(src,dst,off,imm)'
	print '================= result ================================'	

def str2int(input):
	if input.startswith('0x'):
		return int(input,16)
	return int(input)
def char2hex(input):
	return '\\x'+hex(input).replace('0x','').replace('L','').rjust(2,'0')
def encode_single(rl):
	rl = rl.strip()
	result = ''
	if ('(' not in rl) |  (')' not in rl) :
		if 'padding' in rl :
			print '\t"%s"'%('\\x00'*8)
			return
		else:
			print '[-] bad rules '
			exit(-1)
	op = rl.split('(')[0]
	src =  str2int(rl.split('(')[1].split(',')[0])
	dst =  str2int(rl.split('(')[1].split(',')[1])
	off =  str2int(rl.split('(')[1].split(',')[2])
	imm =  str2int(rl.split('(')[1].split(',')[3].split(')')[0])
	#print src,dst,off,imm
	for i in range(256):
		if op.upper() == opcode[i]:
			result += char2hex(i)#'\\x'+ hex(i).replace('0x','').replace('L','').rjust(2,'0')
			break
	if len(result) == 0:
		print '[-] No such insn :',op
		exit(-1)
	result += char2hex((src<<4)+dst)
	result += p16(off)
	result += p32(imm)
	print '\t"%s"'%result

def encode_all(rules):
	for rl in rules.split('\n'):
		if ('padding' in rl) |(('(' in rl)&(')' in rl) ):
			encode_single(rl+')')
def banner_encode():
	print '[+] A tools for encode ebpf rules by P4nda'
	print '[+] modify code in script as format :'
	print '========================================================='
	print '\t\t ALU_MOV_K(0,9,0x0,0xffffffff)'
	print '\t\t JMP_JNE_K(0,9,0x2,0xffffffff)'
	print '\t\t ALU64_MOV_K(0,0,0x0,0x0)'
	print '\t\t LD_IMM_DW(1,9,0x0,0x3)'
	print '\t\t padding \t/*this word will be translateed \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00*/'
	print '\t\t JMP_EXIT(0,0,0x0,0x0)'	
	print '========================================================='	
	print 'result format: \t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"'
	print '================= result ================================'	
def banner():
	print '[+] A tools for encode&decode ebpf rules by P4nda'
	print '[+] modify code in script yourself ,function argv as follow:'
	print '========================================================='
	print 'encode:'
	print '\tebpf_tools.py encode '
	print 'decode:'
	print '\tebpf_tools.py decode '	
	print '========================================================='


if __name__ == '__main__':
	if len(sys.argv) ==1 :
		banner()
		exit(0)
	if sys.argv[1].lower() == 'decode':
		banner_decode()
		decode_all(code)
	elif sys.argv[1].lower() == 'encode':
		banner_encode()
		encode_all(rules)
	else:
		banner()
